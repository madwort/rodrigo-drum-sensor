from drum_sensor.tdoa import calculate_point_crosscorrelate

import numpy
import pytest

testdata = [
    ([80, 45, -42, -83], (-0.08199618647736903, 0.08692143585675399), (0.006395308834651672, 0.006828757223941415)),
]
    # 0, 80, 125, 83
    # -80, -45, 42, 83
    # ([7, 4, 0, 4], (0.004566751345874217, -0.0045667513458737), (0.0005514049304094885, 0.0005514049304090638)),
    # ([0, 82, 136, 82], (-0.10623391246350365, 0.10623391246351387), (0.030940759000152925, 0.030940759000144185)),
    # ([0, 77, 124, 81], (-0.08218499505826882, 0.08871530707404185), (0.00990158369200529, 0.010704979806424278)),
    # ([81, 0, 79, 117], (0.07723815321925999, 0.07392248026592782), (0.003624558160108827, 0.003511846510005707)),
    # ([90, 0, 90, 124], (0.07832980953338092, 0.07832980953338092), (0.012415343915888867, 0.012415343915888867)),
    # ([77, 0, 81, 120], (0.0765109989247526, 0.08304274142552162), (0.0030041510963897703, 0.003283378859201837)),
    # ([133, 82, 0, 82], (0.09840269371389346, -0.09840269371532345), (0.0224956927850102, 0.022495692787188656)),
    # ([119, 87, 0, 91], (0.0785261993011436, -0.07098095162190782), (0.019246954133567223, 0.017297146434860224)),
    # ([117, 89, 0, 91], (0.07533891044074259, -0.07136379917418237), (0.023946112691366265, 0.022613862465255288)),
    # ([83, 135, 87, 0], (-0.10126799320721791, -0.09458298914842288), (0.01969107563898766, 0.01798902955487899)),
    # ([86, 136, 87, 0], (-0.09840541965966135, -0.09673892198645997), (0.01736681004919172, 0.016954451633795754)),
    # ([70, 117, 77, 0], (-0.08603283412602358, -0.07478580908218872), (0.009982940470821529, 0.008864968087728535)),
    # ([87, 106, 36, 0], (-0.0392633947602687, -0.12557977453066305), (0.004837576414917338, 0.010335475412393918)),
    # ([88, 23, 0, 74], (0.10498233546958241, -0.025556539981573347), (0.007440531279096527, 0.004204461519220093)),
    # ([74, 60, 0, 37], (0.03090160796349531, -0.0653344477688675), (0.005821057794036138, 0.007082238385153403)),
    # ([65, 8, 0, 83], (0.041761469703860465, -0.025412289298273678), (0.0959625249688967, 0.013137950206507062)),
    # ([0, 17, 80, 70], (-0.01820749716817085, 0.09879170527924472), (0.0024162853667972746, 0.004120533014859691)),
    # ([15, 0, 60, 66], (0.012801872756658082, 0.07836258890834677), (0.0014703501335117033, 0.0020328893482624154)),

# [-1.499474, -1.498582, -1.499813, -1.498166]
# [0.499487, 0.49989, 0.498524, -1.498255]
# [-1.499378, -1.497931, -1.499587, 0.499883]
# [0.499195, 0.49844, -1.498774, -1.497675]
# [-1.499891, 0.498763, 0.499842, -1.498635]
# [0.499064, 0.499285, -1.498801, -1.498516]
# [0.499267, 0.499007, -1.498435, -1.49762]
# [0.495876, -29.111259, -1.492082, -1.495315]
# [0.495439, -29.715442, 26.289038, -1.492687]
# [0.496974, -31.363886, -1.495949, -1.493518]
# [0.494394, -29.793743, 31.295057, -1.49622]
# [-37.432369, -33.479175, 38.422896, 38.59216]
# [-38.251286, -35.28295, 40.369278, 41.334574]
# [-37.507156, -32.818302, 31.809758, 40.192457]
# [-37.167672, -33.388892, 28.162784, 39.475502]
# [-53.259641, -91.442632, 83.662526, 55.830124]
# [-49.155087, -37.798982, 42.946725, 51.03769]
# [-49.928988, -36.647381, -1.496279, 52.965829]
# [-53.004699, -90.437953, 75.723917, 55.015657]
# [-64.057021, -1.498209, -1.495848, 0.497622]
# [-1.495936, 0.498821, -1.495748, -1.499452]
# [-62.513373, -45.584523, 56.518507, 66.595377]
# [-63.745295, -81.663266, 76.607993, 69.4]
# [0.497023, -40.946325, 40.607806, -1.498567]
# [-76.610723, -81.852569, 78.486943, 76.451051]
# [0.497854, -152.90424, 75.72138, -1.497095]
# [0.496609, 0.498107, 0.498578, 79.045302]


@pytest.mark.parametrize("time_deltas_samples,expected_point,expected_std", testdata)
def test_calculate_point(time_deltas_samples, expected_point, expected_std):
    speed = 82

    #  in m
    distance = 0.202

    x, y, std_x, std_y = calculate_point_crosscorrelate(time_deltas_samples, speed, distance)

    expected_x, expected_y = expected_point
    expected_std_x, expected_std_y = expected_std
    assert numpy.isclose(x, expected_x)
    assert numpy.isclose(y, expected_y)
    assert numpy.isclose(std_x, expected_std_x)
    assert numpy.isclose(std_y, expected_std_y)
